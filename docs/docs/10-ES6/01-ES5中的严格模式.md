


## ES的几个重要版本

- ES5 : 09年发布。

- ES6(ES2015) : 2015年发布，也称为ECMA2015。

- ES7(ES2016) : 2016年发布，也称为ECMA2016  (变化不大)。


## 严格模式的理解

### 概念


**理解**：除了正常运行模式(混杂模式)，ES5添加了第二种运行模式："严格模式"（strict mode）。

顾名思义，这种模式使得Javascript在更严格的语法条件下运行。

**目的**：

- 消除Javascript语法的一些不合理、不严谨之处，减少一些怪异行为

- 消除代码运行的一些不安全之处，为代码的安全运行保驾护航

- 为未来新版本的Javascript做好铺垫

### 使用

- 针对整个脚本文件：将`use strict`放在脚本文件的第一行，则整个脚本文件将以严格模式运行。

- 针对单个函数：将`use strict`放在函数体的第一行，则整个函数以严格模式运行。

PS：如果浏览器不支持，则这句话只解析为一条简单的语句, 没有任何副作用。

脚本文件的变通写法：因为第一种调用方法不利于文件合并，所以更好的做法是，借用第二种方法，将整个脚本文件放在一个立即执行的匿名函数之中。

### 语法和行为改变

- 必须用var声明变量

- 禁止自定义的函数中的this指向window

- 创建eval作用域

- 对象不能有重名的属性


## 严格模式和普通模式的区别

> 下面列举几条严格模式的内容。

### 全局变量显式声明

在正常模式中，如果一个变量没有声明就赋值，默认是全局变量。严格模式禁止这种用法，全局变量必须显式声明。


### 禁止this关键字指向全局对象：

```javascript
        var foo = function () {
            console.log(this);
        }

        foo();
```
上方代码中，普通模式打印的是window。严格模式下打印的是undefined。

### 创设eval作用域



### 禁止使用with语句

因为with语句无法在编译时就确定，属性到底归属哪个对象。


### 构造函数必须通过new实例化对象

构造函数必须通过new实例化对象，否则报错。因为this为undefined，此时无法设置属性。

比如说：


```
        var Cat = function (name) {
            this.name = name;
        }

        Cat('haha');
```

上方代码中，如果在严格模式下，则会报错。


### 为了让代码更安全，禁止函数内部遍历调用栈

### 严格模式下无法删除变量


### 属性相关

普通模式下，对一个对象的只读属性进行赋值，不会报错，只会默默地失败。严格模式下，将报错。

严格模式下，对禁止扩展的对象添加新属性，会报错。

普通模式下，如果对象有多个重名属性，最后赋值的那个属性会覆盖前面的值。严格模式下，这属于语法错误。


普通模式下，如果函数有多个重名的参数，可以用arguments[i]读取。严格模式下，多个重名的参数属于语法错误。


比如下面这样的代码：

```javascript
	var obj = {
		username: 'smyh';
		username: 'vae'
	}
```

上面的代码，在严格模式下属于语法错误，因为有重名的属性。

### 函数必须声明在顶层


将来Javascript的新版本会引入"块级作用域"。为了与新版本接轨，严格模式只允许在全局作用域或函数作用域的顶层声明函数。也就是说，不允许在非函数的代码块内声明函数。

### 新增关键字

为了向将来Javascript的新版本过渡，严格模式新增了一些保留字：implements, interface, let, package, private, protected, public, static, yield。


## 总结

至少要能答出四五条。


参考链接：

- [阮一峰 | Javascript 严格模式详解](http://www.ruanyifeng.com/blog/2013/01/javascript_strict_mode.html)



